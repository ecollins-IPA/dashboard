---
title: "Quality Reports: Migrations Decision Survey"
date: "3/4/2020"
output: 
  html_document:
    number_sections: TRUE
    toc: TRUE
---

```{r setupmaster, include=FALSE}
rm(list=ls(all=TRUE))
knitr::opts_chunk$set(echo = TRUE)


# library(devtools) 
# install_github("hemken/Statamarkdown")
# library(Statamarkdown)
library(knitr)
library("xlsx")
library(foreign)
library(geosphere)
#library(kableExtra)
# library(stargazer)
# library(readstata13)
# if(!exists("stataexe")) stataexe <- "C:/Stata15/StataMP-64.exe"
# knitr::opts_chunk$set(engine.path=list(stata=stataexe))
library(tidyverse)
```

# Options

Indicate batch. 

```{r}
recompile_data       <- FALSE # Currently commented out 
remove_training_data <- TRUE   
batchdate            <- "20200323"
since                <- 1     # Report is for last `since` days (default to 1)
make_reports         <- FALSE
savedata             <- FALSE # Whether to save data (stata / csv)
```


<!-- ```{r, echo = FALSE} -->
<!-- write_file(paste("global batch", batchdate), "0_batch_name.do") -->
<!-- ``` -->

<!-- ```{stata, collectcode=TRUE, include = FALSE, eval = recompile_data} -->
<!-- version 13 -->

<!-- do "0_batch_name.do" -->

<!-- * subdirectory containing raw data -->
<!--     global D1 "1_data_in\\$batch" -->

<!-- * subdirectory containing output -->
<!--     global D2 "2_data_out/$batch/" -->
<!--   	capture mkdir $D2 -->

<!-- * output data file -->
<!--     global baseline "$D2\\baseline.dta" -->
<!--     global baseline_only "$D2\\baseline_only.dta" -->

<!-- * run text audits / creates media/TA_all.dta -->
<!--   do "2_text_audits.do" -->

<!-- * Combine data and run duration checks -->
<!--   do "3_data_check.do" -->

<!-- * Location checks (As the crow flies) -->
<!--   do "4_location_check.do" -->

<!-- ``` -->

```{r, echo = FALSE}
# baseline <- readstata13::read.dta13(paste0("2_data_out/", batchdate, "/baseline.dta"), generate.factors = TRUE, noint.factors = TRUE) %>% dplyr:: mutate(form_id = 1:n())

baseline <- readstata13::read.dta13(paste0("2_data_out/", batchdate, "/baseline.dta"), generate.factors = TRUE, nonint.factors = TRUE) %>% 
  dplyr:: mutate(form_id = 1:n()) %>%
  as.data.frame()

#if(remove_training_data) baseline <- filter(baseline, toupper(hh_id) != "PPPPP")
if(remove_training_data) baseline <- filter(baseline, as.Date(submissiondate, "%m/%d/%Y") >= "2020-03-09")

today    <- as.Date(batchdate, format = "%Y %m %d")
baseline <- mutate(baseline, in_period =  today - as.Date(baseline$submissiondate, "%m/%d/%Y") < since)


```



```{r, echo = FALSE}

# Chunk to add supervisors

# enum_df <- data.frame(enum_name = c(as.character(11:60), "other"), 
#                       enumerator = c("Adebayo Serah", "Adedoyin Adewale", "Agbebiyi Mojisola", "Aghedo Sylvester", "Akalazu Ogechi Lucy", "Akinwole John. M", "Amadi Joeakin Chinedu", "Anyanwu Esther", "Anyanwu Faithful Chiamaka", "Augustina Oji Ogar", "Blessing Osahon", "Bunmi Ishola", "Cheryl Alegiemo", "Chidiebere Phina Ikpenwa", "Chimkanma Nwachukwu", "Chinedu Anikwe", "Eberechukwu Alchedo", "Efetobore Eseoghene", "Eze Henry Kelechukwu", "Feyipitan Adewole", "Godspower Lambert", "Halimah Usman Aimonoromo", "Ifeakor Gabriel Osita", "Imabong Akai", "Joy Chia", "Joy Chidinma", "Kiyinne Jonah Iberi", "Kosipre Tuowei Micheal", "Nnaka Alex chike", "Nneamaka Franklin", "Nwakaogor Glory Ugochukwu", "Nwoye Henry", "Obinnaia Samuel", "Oghenerukewe Judah", "Ojebor Humphrey", "Okafor Tyndale Chimezie", "Okechukwu Obiozo", "Okonkwo Vivian", "Okorie Blessing", "Okorogri-Shadrack Eseoghene", "Okpowo Smart Raphael", "Ozoemene Precious", "Paschal Chidiebere Egbuchulem", "Salem Omolara Roseline", "Tadaferua Kelvin Ogaga", "Ube Josephine Orieoma", "Umeadi Charles C", "Unem Iwodi", "Vany Ude", "Vera Lambert", "Other"))


baseline <- baseline%>%
 
  # mutate(supervisor_name = case_when(supervisor_current == 1 ~ "Faith Okojie",
  #                                    supervisor_current == 2 ~ "Fortune Egedegbe",
  #                                    supervisor_current == 3 ~ "Ifeoma Martha Ezike",
  #                                    supervisor_current == 4 ~ "Mary Joy Barah",
  #                                    supervisor_current == 6 ~ "Ojisua Eseaname",
  #                                    supervisor_current == 7 ~ "Stephen Andew",
  #                                    supervisor_current == 9 ~ "Okafor Tyndale",
  #                                    supervisor_current == 10 ~ "Okpowo Smart",
  #                                    supervisor_current == 11 ~ "Oraz Chinello"
  #   
  # )) 

mutate(supervisor_name = supervisor_current)


# baseline <- left_join(baseline, enum_df, "enum_name") %>% 
#   mutate(supervisor_current = ifelse(supervisor_current=="", "missing", supervisor_current)) %>%
#   mutate(team = supervisor_name)

baseline <- baseline %>% 
  mutate(supervisor_current = ifelse(supervisor_current=="", "missing", supervisor_current)) %>%
  mutate(team = supervisor_name)


#baseline <- mutate(baseline, enumerator = forcats::fct_explicit_na(enumerator))
baseline <- mutate(baseline, enumerator = enum_name)

```

# Basic Data Descriptions

## How many surveys completed and when?

```{r, echo = FALSE}
# How far did they get?
baseline <- mutate(baseline, 
                   stage_start      = 1,
                   stage_located    = located =="yes",
                   stage_hh_consent = hh_consent == "yes",
                   stage_consent    = indiv_consent == "yes",
                   stage_complete   = (who_sent_us!= "refuse" & who_sent_us!= ""))

```

```{r, echo = FALSE}
par(mfrow = c(1,2))

hist(as.Date(baseline$end, "%m/%d/%Y"), 30, main = paste("Total tried = ",  sum(!is.na(baseline$end))), xlab = "Date")

with(filter(baseline, stage_consent),
hist(as.Date(end, "%m/%d/%Y"), 30, main = paste("Total w/ indiv consent = ",  sum(!is.na(end)))), xlab = "Date")
     
```


```{r, echo = FALSE}

baseline %>%  select(starts_with("stage_")) %>%
    summarise_all(sum, na.rm = TRUE)  %>% 
    dplyr::mutate_if(is.numeric, round, 2) %>%
    kable(caption = "Number of surveys at different stages")


```

# Structural Checks

## Inconsistent ID entries

```{r, echo = FALSE}
if(!all((baseline$hh_id == baseline$hh_id_reentry))) {
  print("FLAG: hh_id and hh_id_reeentry are not matching in some cases!")
  print(table(baseline$hh_id != baseline$hh_id_reentry))
} else {
  print("hh_id and hh_id_reeentry matching in all  cases!")
  }
```

## Duplicates

```{r, echo = FALSE}

duplicates <- filter(baseline, stage_consent) %>% select(hh_id) %>% filter(duplicated(toupper(hh_id)))

baseline <- mutate(baseline, 
                   flag_duplicated = unlist(toupper(baseline$hh_id)) %in% unlist(duplicates),
                   flag_duplicated = ifelse(stage_consent, flag_duplicated, NA))

table(baseline$flag_duplicated) %>% kable(caption = "duplicated IDs (in cases with individual consent)", col.names = c("Duplicated", "Freq"))

```

## Treatment Balance

```{r, echo = FALSE}
table(baseline$treat_t1) %>% kable(caption = "Treatment Balance", col.names = c("Treatment", "Freq"))
```


## Duration

```{r, echo = FALSE}
baseline <- mutate(baseline, 
                   flag_duration_1 = duration>=200  | duration<=30,
                   flag_duration_2 = duration_ta>=200  | duration_ta<=30)
#baseline <- mutate(baseline, 
#                   duration_final = duration_final - duration_migration2)

if(mean(baseline$flag_duration_1,na.rm = TRUE) > .05) {
  print("MORE THAN 5% HAVE BAD DURATIONS")
hist(baseline$duration, breaks = 30, main = "All durations", xlab = "minutes")}

```

<!-- * **Bad duration check 1**: If <0 or >= 200.  Share with bad duration based on start end: `r mean(baseline$flag_duration_1)`. -->

<!-- * **Bad duration check 2**: If <0 or >= 200.  Share with bad duration based on ta forms: `r mean(baseline$flag_duration_2)`. -->
  

```{r, echo = FALSE}
baseline <- baseline %>% 
  mutate(treatment_duration  = (duration_migration2 - duration_intervention)/60,
        treatment_duration  = ifelse(stage_consent & treat_t1,  treatment_duration, NA), 
        flag_treatment_duration = treatment_duration < 15, 
        duration_survey = duration_finish/60,
        last_duration = (duration_finish - duration_migration2)/60,
        last_duration == ifelse(last_duration >1 & last_duration<40, last_duration, NA))
```
    
    
```{r, echo = FALSE}
par(mfrow = c(1,2))
  hist(baseline$treat_duration_m[baseline$treatment_migration_video=="confirm"], 
     main = paste("Duration of treatment\n(confirmed cases) n = ", length(baseline$treat_duration_m[baseline$treatment_migration_video=="confirm"])), breaks = 30, xlab = "minutes")

  hist(baseline$treatment_duration, breaks = 30, xlab = "minutes", main = "Treatment duration  | treat, consent") 
  
with(filter(baseline, indiv_consent == "yes"), hist(duration_survey, breaks = 30, main = "length individual surveys", xlab = "minutes"))

```

## Export audio files for short treatments from this batch

Select 10 surveys at random to listen to one of the three audio files, at random.
Also select any files that have a treatment duration < 8.

```{r, echo = FALSE, include= FALSE}
n <- sum(baseline$in_period &  baseline$stage_consent, na.rm = TRUE)
set.seed(1)
sample_audio <- (1:n) %in% sample(n, 20)

jobs <- filter(baseline, in_period & stage_consent ) %>%
        filter((treatment_duration < 8) | sample_audio) %>%
        select(enumerator, hh_id, stage_consent, treat_t1,  treatment_duration,
          duration_intervention, duration_migration2, video_reliable, 
          audio_treatment, audio_social_media, cont_audio_gift) %>%
        dplyr:: mutate(audit_type = sample(c("treat", "social", "pay", "social", "pay"), n(), replace = TRUE)) %>%
        mutate(audit_type = ifelse(!is.na(treatment_duration) & treatment_duration < 8, "treat", audit_type)) %>%
        mutate(file = ifelse(audit_type == "treat", audio_treatment, NA)) %>%
        mutate(file = ifelse(audit_type == "social", audio_social_media, file)) %>%
        mutate(file = ifelse(audit_type == "pay", cont_audio_gift, file)) %>%
        arrange(audit_type)         

kable(select(jobs, enumerator, hh_id, treatment_duration, audit_type), caption = "Surveys with too short treatment durations, audio files exported for review.")

# Make folders
audio_check_folder <- paste0(getwd(), "/5_audio_checks/", batchdate)
dir.create(audio_check_folder )

# Save a task list
write.xlsx(
  select(jobs, enumerator,	hh_id,	treatment_duration, file, audit_type) %>%
  mutate(checked = "", relevant_text = "", respondent_present = ""),
  paste0(audio_check_folder, "/joblist.xlsx"), row.names = FALSE
  )



# Copy over files
for(job in jobs$file){
  if(job != ""){
  file_to_copy <- paste0(getwd(), "/1_data_in/", batchdate, "/", job)
  file_to_copy <- gsub("\\\\", "/", file_to_copy)
  file.copy(file_to_copy, audio_check_folder)}
}

```




## Are self administered questions self administered?

```{r, echo = FALSE}
baseline <- mutate(baseline, flag_self_admin = (
  (own_routes_selfad == "enumerator") + 
  (journey_risks_selfad_post=="enumerator") + 
  (migration_irr_pre_selfad == "enumerator"))/3,
  flag_self_admin = ifelse(own_routes_selfad=="" | journey_risks_selfad_post=="", NA, flag_self_admin))

self_admin <- table(baseline$flag_self_admin)
names(self_admin) <- round(as.numeric(names(self_admin)), 2)
round(self_admin, 2) %>% kable(caption = "Share self administered", digits = 2, col.names = c("Share not self administered", "Freq"))
```


```{r, echo = FALSE, eval = FALSE}
## In sequence?
#baseline <- mutate(baseline, flag_sequence = inseq==0)
#table(baseline$flag_sequence, baseline$treatment_migration_video == "confirm") %>% kable
```


## Location Checks

```{r, echo = FALSE, results = "asis", eval = FALSE}
location_data <- readstata13::read.dta13(paste0("2_data_out/", batchdate, "/location_checks.dta"))
plot(location_data$dist_start_rec/1000, location_data$dist_start_back)
# plot(log(1+location_data$dist_start_rec/1000), log(1+location_data$dist_start_back/1000))
Md1 <- lm(dist_start_rec ~ factor(enum_name), data = location_data)
Md2 <- lm(dist_start_back ~ factor(enum_name), data = location_data)
stargazer(Md1, Md2, type = "html")

```


```{r, echo = FALSE}

coords <- select(baseline, coordinates_startlongitude, coordinates_startlatitude,          coordinates_backgroundlongitude, coordinates_backgroundlatitude)

baseline$distance_start_back <- apply(coords, 1, function(j) geosphere::distm(c(j[1], j[2]), c(j[3], j[4])))

coords2 <- select(baseline, coordinates_startlongitude, coordinates_startlatitude,          rec_Longitude, rec_Latitude)

baseline$distance_start_rec <- apply(coords2, 1, function(j) geosphere::distm(c(j[1], j[2]), c(j[3], j[4])))
#baseline$distance_start_rec <- NA

par(mfrow = c(1,2))
with(baseline, {
     hist(distance_start_back[distance_start_back<500], breaks = 30, main = "distance: start v background check", xlim = c(0, 300), xlab = "meters")
     hist(distance_start_rec[distance_start_rec<500], breaks = 30, main = "distance: start v recruitment point", xlim = c(0, 300), xlab = "meters")
     }
     )
# fun = distHaversine
```

## IDs Link  [To Dos]

Contact IDs correspond with HH IDs.

## Refusals

Refusals flag is based on refusals for four questions: bdm1, income, democratic values, and asylum. Share refusals:

```{r, echo = FALSE}
#baseline <- mutate(baseline, flag_refusals = ((risk_bdm1 == - 99) + (income_hh == -99) + (democratic_values_2== "refuse") + (nig_asyl==-99))/4)
baseline <- mutate(baseline, flag_refusals = ((risk_bdm1 == - 99) + (income_hh == -99)  + (nig_asyl==-99))/3)
table(baseline$flag_refusals)
```

# Backcheck  [To Dos]

## Enumerator flags  [To Dos]

## Mismatch rate   [To Dos]

Calculate mismatch rate

# Content consistency

## Gender balance

Showing balance broken down by `indiv_consent`:

```{r, echo = FALSE, warning = FALSE}

baseline <- mutate(baseline, gender_numeric = dplyr::recode(gender, "male" = 1, "female" = 0))

gender_balance = mean(baseline$gender_numeric, na.rm = TRUE)

with(baseline, table(gender)) %>% 
  kable(caption = paste("Gender balance of in-depth respondent, Mean:",  round(gender_balance, 2)))

if(mean(abs(gender_balance - .5))> .05) print(paste("Gender imbalance is large"))

```

Gender balance in roster for consenting and non-consenting households

```{r,echo = FALSE}
gender_roster <- 
  baseline %>% 
  filter(stage_hh_consent) %>% 
  select(form_id, starts_with("gender_roster_")) 

gender_roster <- gender_roster %>%
  mutate(share_male = apply(gender_roster=="male", 1, sum) / apply(gender_roster=="male" | gender_roster=="female", 1, sum)) %>%
  select(form_id, share_male)

baseline <- left_join(baseline, gender_roster)

par(mfrow = 1:2)
hist(baseline$share_male[baseline$stage_consent], breaks = 30, main = paste("share male /n(consenting hhs);  ", mean(baseline$share_male[baseline$stage_consent], na.rm = TRUE)), xlab = "share")
hist(baseline$share_male[!baseline$stage_consent], breaks = 30, main = paste("share male \n(non consenting hhs) = ", mean(baseline$share_male[!baseline$stage_consent], na.rm = TRUE)), xlab = "share")

```

```{r, echo = FALSE}
# Gender of HHH: This can be done better!

baseline = mutate(baseline, gender_hhh = NA) %>%
           mutate(gender_hhh = ifelse(relation_roster_1 == "self", gender_roster_1, gender_hhh)) %>%
           mutate(gender_hhh = ifelse(relation_roster_2 == "self", gender_roster_2, gender_hhh)) %>%
           mutate(gender_hhh = ifelse(relation_roster_3 == "self", gender_roster_3, gender_hhh)) %>%
           mutate(gender_hhh = ifelse(relation_roster_4 == "self", gender_roster_4, gender_hhh)) %>%
           mutate(gender_hhh = ifelse(relation_roster_5 == "self", gender_roster_5, gender_hhh))

with(baseline, table(gender_hhh)) %>% 
  kable(caption = "Gender balance of first respondent (HHH)")


```

## Raven

Are raven's answers making sense?

```{r, echo = FALSE}
ravens_results <- sapply(letters[1:8], function(j) {
sapply( list(baseline$raven_spm_a11, baseline$raven_spm_b12, baseline$raven_spm_c4, baseline$raven_spm_d7, baseline$raven_spm_e1), function(v) sum(v==j))})

kable(ravens_results, caption = "Correct results would be d, e, h, e, g")

baseline <- mutate(baseline,
       raven_spm_a11_correct = raven_spm_a11=="d", 
       raven_spm_b12_correct = raven_spm_b12 == "e", 
       raven_spm_c4_correct = raven_spm_b12 == "h", 
       raven_spm_d7_correct = raven_spm_b12 == "e", 
       raven_spm_e1_correct = raven_spm_b12 == "g")

corrects <- select(baseline, ends_with("correct")) %>% head

```


## Are the Hanoi numbers possible? plausible?

```{r, echo = FALSE}

baseline <- mutate(baseline, 
         hanoi_impossible1 = hanoi_moves1 >0 & hanoi_moves1 <7,
         hanoi_impossible2 = hanoi_moves2 >0 & hanoi_moves2 <7)

with(filter(baseline, hanoi_moves1 >=0 & hanoi_moves2 >=0) %>% dplyr:: mutate(noise1 = .5*runif(n()), noise2 = .5*runif(n())),
plot(hanoi_moves1 + noise1 - .25, hanoi_moves2 + noise1 - .25), cex = .1)
abline(a = 0, b = 1)
```

 * Share of impossible moves for Hanoi 1: `r mean(baseline$hanoi_impossible1, na.rm = TRUE)`
* Share of impossible moves for Hanoi 1: `r mean(baseline$hanoi_impossible2, na.rm = TRUE)` 
* Correlation of efforts 1 and 2: `r with(filter(baseline, hanoi_moves1 >=0 & hanoi_moves2 >=0 ), cor(hanoi_moves1, hanoi_moves2, use =  "pairwise.complete.obs"))`


## Consistency of norm answers

People who think that people should not cut out should not also think that its ok to travel by routes.

```{r, echo = FALSE}
norms_df <- select(baseline, starts_with("norms")) 
norms_df[norms_df <0 ] <- NA
norms_df %>% cor(use = "pairwise.complete.obs")  %>% kable(digits = 2)

```

*Should* these all be highly correlated?


## Consistency of democracy questions

```{r, echo = FALSE, warning = FALSE, message = FALSE}

select(baseline, starts_with("democratic_val")) %>% 
  mutate_if(function(x) !is.numeric(x), as.numeric)  %>% 
    mutate_each(funs(replace(., .<0, NA))) %>% 
  cor(use =  "pairwise.complete.obs") %>% kable(digits = 2)

```

## Do BDM answers make sense?

```{r, echo = FALSE}
df <- select(baseline, starts_with("risk_bd")) 
df[df < 0 ] <- NA
df %>% summarise_all(mean, na.rm = TRUE) %>% kable(digits = 2)
cor(df, use =  "pairwise.complete.obs") %>% kable(digits = 2)
```

## Do key outcome measures vary?

```{r,  comment = ""}
(table(baseline$migration_irregular_change))
(table(baseline$migration_irregular_post))
(table(baseline$migration_irregular_pre))
```


## Who sent us?

```{r whosent, echo = FALSE}

table(baseline$who_sent_us) %>% kable(col.names = c("Who?", "Frequency"))

```

# Enumerator flags

```{r, echo = FALSE}
fes <- baseline %>% 
  mutate(bdm1 = ifelse(risk_bdm1 >=0, risk_bdm1, NA)) %>%
  mutate(hanoi1 = ifelse(hanoi_moves1 >=0, hanoi_moves1, NA)) %>%
  mutate(distance_censored = ifelse(distance_start_back >=300, 300, distance_start_back)) %>%
  select(enumerator, duration, hanoi1, bdm1, distance_censored) %>%
  group_by(enumerator) %>%
  summarize_all(mean, na.rm = TRUE)
scaled <- apply(fes[,-1], 2, scale)
fes_scaled <- cbind(fes[,1], scaled, score = apply(scaled, 1, function(j) {
  2*abs(j[1]) + abs(j[2]) + abs(j[3]) - 2*(j[4])  }
  )) %>% 
  data.frame %>% arrange(score)

kable(fes_scaled, digits = 2, caption = "Enumerator flags / deviations")
```

# Reports

## Enumerator Reports

Sheets per supervisor. If enumerator enters the wrong supervisor then their reports will fall in that supervisor's report.

```{r, echo = FALSE, include = FALSE, eval = make_reports}

enumerator_summary <-
    filter(baseline, in_period) %>%
    select(enumerator, supervisor_name,
           treatment_duration, last_duration,  duration_survey, 
           flag_duplicated, distance_start_rec, distance_start_back) %>%
    group_by(supervisor_name, enumerator) %>%
    summarise_all(mean,  na.rm = TRUE)  %>% 
    dplyr::mutate_if(is.numeric, round, 2)


enumerator_summary_long <-
    baseline %>%
    select(enumerator, supervisor_name, 
           gender_numeric, adult_roster_count,  flag_self_admin, flag_refusals, duration_survey, distance_start_rec, distance_start_back) %>%
           #gender_numeric, adult_roster_count,  flag_self_admin, duration_survey, distance_start_rec, distance_start_back) %>%
    group_by(supervisor_name, enumerator) %>%
    summarise_all(mean, na.rm = TRUE)  %>% 
    dplyr::mutate_if(is.numeric, round, 2)

for(j in sort(unique(baseline$supervisor_name))){
  
  team_report <-
    enumerator_summary %>% 
    filter(supervisor_name == j)

  # Gets sums of vars for the whole period  
  report_count_long <- baseline %>%
    filter(supervisor_name == j) %>%
    select(enumerator, stage_complete) %>%
    group_by(enumerator) %>%
    summarise_all(sum, na.rm = TRUE)

  # Gets means of vars for the whole period  
  team_report_long <-
    enumerator_summary_long %>%
    filter(supervisor_name == j)%>%
    left_join(report_count_long)
  
  # Gets sums of numbers for last period  
  team_report_count <-
    filter(baseline, in_period) %>%
    filter(supervisor_name == j) %>%
    select(enumerator, starts_with("stage")) %>%
    group_by(enumerator) %>%
    summarise_all(sum, na.rm = TRUE) 
  
## Write output
team_path <- paste0(getwd(), "/4_team_reports/team_", j)
dir.create(team_path)

# foreign::write.dta(enumerator_summary, paste0(team_path, "/", batchdate, "_", j, ".dta"))

rmarkdown::render("4_team_reports/report_generator.Rmd", 
                    output_file = paste0(team_path, "/", batchdate, "_", j, ".pdf"), 
                    params = list(set_title = paste0("Team ", j, ": Report for ", batchdate)))  

}
```

General report export

```{r, echo = FALSE, eval = savedata}

dir.create( paste0("3_reports/",  batchdate))
write.csv(enumerator_summary, paste0("3_reports/",  batchdate, "/summary.csv"))
write.csv(baseline, paste0("3_reports/", batchdate, "/baseline.csv"))
haven::write_dta(baseline, paste0("3_reports/", batchdate, "/baseline.dta"))

```
  
end.







